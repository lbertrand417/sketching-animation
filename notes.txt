synchronize(path){
        // TODO: remplacer cleanPos par unsync
        if(path.positions.length != 0) {
            
            //console.log('detail currentTime', this.currentTime);
            //console.log('path currentTime', path.currentTime);

            /*let currentCurve = curves.filter(value => 
                ((this.timings[value.beginning] <= this.currentTime) && (this.timings[value.end] >= this.currentTime)))[0];*/
            let currentCurve = this._curves.findIndex(value => 
                (value.syncT[0] <= this.currentTime) && (value.syncT[value.syncT.length - 1]>= this.currentTime));
            //console.log('detail curves', this._curves)
            console.log('curve', currentCurve);

            // Find extremum of the current curve in the parent path
            //let parentCurves = extractCurves(path.positions);
            //console.log(parentCurves)
            //console.log(path.currentTime);
            /*let currentParentCurve = path.curves.filter(value => 
                ((path.timings[value.beginning] <= path.currentTime) && (path.timings[value.end] >= path.currentTime)))[0];*/
            let currentParentCurve = path.curves.filter(value => 
                (value.syncT[0] <= path.currentTime) && (value.syncT[value.syncT.length - 1]>= path.currentTime))[0];
            //console.log('parent syncTimings', currentParentCurve.syncT);

            //console.log('detail timings', this._timings)
            //console.log('parent timings', path.timings);

            // Find extremum of this path
            /*console.log('detail')
            let begin = 0;
            let L = Math.floor(this.timings.length / 2);
            let end = L;
            let axis = this.positions[end].clone().sub(this.positions[begin])

            console.log('parent')
            let parentBegin = 0;
            let parentEnd = Math.floor(path.timings.length / 2);
            let parentAxis = path.positions[parentEnd].clone().sub(path.positions[parentBegin]);*/

            //if (this.timings[currentCurve.beginning] != path.timings[currentParentCurve.beginning] || this.timings[currentCurve.end] == path.timings[currentParentCurve.end]) {
            if(this._curves[currentCurve].syncT[0] != currentParentCurve.syncT[0] || 
                        this._curves[currentCurve].syncT[this._curves[currentCurve].syncT.length - 1] != currentParentCurve.syncT[currentParentCurve.syncT.length - 1]) { // TODO or if parent curve change cur donc je dois tester les extremums aussi
                console.log("change curve");
                this._curveIndex = currentCurve;

                // Reinitialize sync
                //this.positions = [...this.positions];
                //this.timings = [...this.unsyncTimings];

                //console.log(this.timings);

                //console.log('before', this._positions);

                /*if (axis.dot(parentAxis) < 0) {
                    for (let i = 0; i < L; i++) {
                        this.shift();
                    }
                }*/

                /*console.log('after', this._positions);

                console.log('begin', begin);
                console.log('end', end);
                console.log("parent begin", parentBegin);
                console.log("parentEnd", parentEnd)*/

                //let leftOffset = this.timings[begin] - path.timings[parentBegin];
                //let leftOffset = this.timings[currentCurve.beginning] - path.timings[currentParentCurve.beginning];
                /*let leftOffset = this.unsyncTimings[beginning] - path.timings[currentParentCurve.beginning];
                /*console.log(this.timings[currentCurve.beginning])
                console.log(path.timings[currentParentCurve.beginning])
                console.log(leftOffset);
                this.offsetTiming(-leftOffset); // OK*/

                /*console.log(path.timings)
                console.log(this.unsyncTimings);
                console.log(this.timings);*/

                //let newTimings = [...this.timings];
                //newTimings[begin] = path.timings[parentBegin];
                //newTimings[end] = path.timings[parentEnd];
                //let parentDenom = path.timings[parentEnd] - path.timings[parentBegin];
                //let parentDenom = path.timings[currentParentCurve.end] - path.timings[currentParentCurve.beginning];
                let parentDenom = currentParentCurve.syncT[currentParentCurve.syncT.length - 1] - currentParentCurve.syncT[0];

                //let detailDenom = this.timings[end] - this.timings[begin];
                //let detailDenom = this.timings[end] - this.timings[beginning];
                let detailDenom = this._curves[currentCurve].unsyncT[this._curves[currentCurve].unsyncT.length - 1] - this._curves[currentCurve].unsyncT[0];

                console.log('parentDenom', parentDenom);
                console.log('detailDenom', detailDenom);

                //for (let i = begin + 1; i < end; i++) {
                /*for (let i = currentCurve.beginning + 1; i < this.timings.length; i++) {
                    newTimings[i] = (this.timings[i] - this.timings[i-1]) / detailDenom * parentDenom + newTimings[i-1];
                }*/

                // Synchronize THE curve
                let theCurve = this._curves[currentCurve];
                theCurve.syncT = [...theCurve.unsyncT];
                theCurve.syncT[0] = currentParentCurve.syncT[0];
                for (let i = 1; i < theCurve.unsyncT.length; i++) {
                    theCurve.syncT[i] = (theCurve.unsyncT[i] - theCurve.unsyncT[i-1]) / detailDenom * parentDenom + theCurve.syncT[i-1];
                }

                // TODO: ne pas faire du retime mais utiliser timings du parent pour avoir exactement le mÃªme nombre de points
                



                /*while(path.timings.length != theCurve.syncT.length) {
                    theCurve.syncPos.pop();
                    theCurve.syncT.pop();
                }*/

                for (let l = currentCurve + 1; l < this._curves.length; l++) {
                    this._curves[l].syncT = [...this._curves[l].unsyncT];
                    this._curves[l].syncT[0] = (this._curves[l].unsyncT[0] - this._curves[l-1].unsyncT[this._curves[l-1].unsyncT.length - 1]) 
                                            / detailDenom * parentDenom + this._curves[l-1].syncT[this._curves[l-1].syncT.length - 1];
                    for (let i = 1; i < this._curves[l].syncT.length; i++) {
                        this._curves[l].syncT[i] = (this._curves[l].unsyncT[i] - this._curves[l].unsyncT[i-1]) / detailDenom * parentDenom + this._curves[l].syncT[i-1];
                    }
                }

                /*for (let i = end; i < this.timings.length; i++) {

                    newTimings[i] = (this.timings[i] - this.timings[i-1]) / detailDenom * parentDenom + newTimings[i-1];
                }*/

                //for (let i = begin; i >= 0; i--) {
                /*for (let i = currentCurve.beginning - 1; i >= 0; i--) {
                    newTimings[i] = newTimings[i+1] - (this.timings[i+1] - this.timings[i]) / detailDenom * parentDenom;
                }*/

                for (let l = currentCurve - 1; l >= 0; l--) {
                    this._curves[l].syncT = [...this._curves[l].unsyncT];
                    this._curves[l].syncT[this._curves[l].syncT.length - 1] = this._curves[l+1].syncT[0] 
                                                                        - (this._curves[l+1].unsyncT[0] - this._curves[l].unsyncT[this._curves[l].syncT.length - 1]) 
                                                                        / detailDenom * parentDenom;
                    for (let i = this._curves[l].syncT.length - 2; i >= 0; i--) {
                        this._curves[l].syncT[i] = this._curves[l].syncT[i+1] - (this._curves[l].unsyncT[i+1] - this._curves[l].unsyncT[i]) / detailDenom * parentDenom;
                    }
                }

                this.positions = [];
                this.timings = [];
                for(let l = 0; l < this._curves.length; l++) {
                    this._curves[l].syncT = this._curves[l].syncT.map( function(value) { 
                        return Math.round((value + Number.EPSILON) * 100) / 100; 
                    } );

                    console.log('round', this._curves[l].syncT);
    
                    let retimed = retime(this._curves[l].syncT, this._curves[l].syncPos);

                    this._curves[l].syncT = [...retimed.tempT];
                    this._curves[l].syncPos = [...retimed.tempPos]

                    console.log('retimed', this._curves[l].syncT);

                    this.positions = this.positions.concat(retimed.tempPos);
                    this.timings = this.timings.concat(retimed.tempT)

                    console.log(this.positions);
                    console.log(this.timings);
                }

                /*newTimings = newTimings.map( function(value) { 
                    return Math.round((value + Number.EPSILON) * 100) / 100; 
                } );

                console.log("new timings 1", newTimings)*/

                //console.log(newTimings);
                //console.log(this.positions);

                /*let retimed = retime(newTimings, this.positions);
                this.positions = [...retimed.tempPos];
                this.timings = [...retimed.tempT];

                console.log(this.positions);
                console.log(this.timings);*/

                //this.positions = [...theCurve.syncPos];
                //this.timings = [...theCurve.syncT];


                /*let tempPos = [];
                let tempT = [];
                for(let i = 0; i < path.timings.length; i++) {

                    let objectTime = path.timings[i];
                    while (objectTime < newTimings[0]) {
                        objectTime += path.timings.length * 16;
                    }

                    while (objectTime > newTimings[newTimings.length - 1]) {
                        objectTime -= path.timings.length * 16;
                    }


                    let info = findInArray(objectTime, newTimings);
                    if(tempT.length > 0 && objectTime < tempT[0]) {
                        if(info.i + 1 < this.positions.length) {
                            tempPos.unshift(interpolate(this.positions[info.i], this.positions[info.i + 1], info.alpha));
                        } else {
                            console.log("coucou")
                            tempPos.unshift(this.positions[info.i]);
                        }
                        tempT.unshift(objectTime);
                    } else if (tempT.length > 0 && objectTime > tempT[tempT.length - 1]) {
                        if(info.i + 1 < this.positions.length) {
                            tempPos.push(interpolate(this.positions[info.i], this.positions[info.i + 1], info.alpha));
                        } else {
                            console.log("coucou")
                            tempPos.push(this.positions[info.i]);
                        }
                        tempT.push(objectTime);
                    } else {
                        let index = findInArray(objectTime, tempT);
                        console.log('index', index)
                        console.log('before', tempT);
                        tempT.splice(index, 0, objectTime);
                        if(info.i + 1 < this.positions.length) {
                            tempPos.splice(index + 1, 0, interpolate(this.positions[info.i], this.positions[info.i + 1], info.alpha));
                        } else {
                            tempPos.splice(index + 1, 0, this.positions[info.i]);
                        }
                        console.log('after', tempT);
                    }
                }*/
            
                /*console.log('original', this.timings);
                console.log('new', newTimings)
                //console.log('retiming', retimed.tempT)
                console.log('retiming', tempPos)
                console.log('retiming', tempT)
                console.log('parent', path.timings);
                
                this.positions = [...tempPos];
                this.timings = [...tempT];*/
            }
        }
    }